// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using CoreWf.Expressions;
using CoreWf.Hosting;
using CoreWf.Runtime;
using CoreWf.Validation;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.Reflection;
using System.Threading;

namespace CoreWf
{
    //[ContentProperty("Implementation")]
    public abstract class Activity
    {
        private const string generatedArgumentPrefix = "Argument";
        private static int s_nextCacheId;

        private static readonly IList<Activity> s_emptyChildren = new List<Activity>(0);
        private static readonly IList<Variable> s_emptyVariables = new List<Variable>(0);
        private static readonly IList<RuntimeArgument> s_emptyArguments = new List<RuntimeArgument>(0);
        private static readonly IList<ActivityDelegate> s_emptyDelegates = new List<ActivityDelegate>(0);

        internal static readonly ReadOnlyCollection<Constraint> EmptyConstraints = new ReadOnlyCollection<Constraint>(new Constraint[0]);

        private string _displayName;
        private bool _isDisplayNameSet;
        private int _id;
        private RootProperties _rootProperties;

        private IList<RuntimeArgument> _arguments;

        private IList<Activity> _children;
        private IList<Activity> _implementationChildren;
        private IList<Activity> _importedChildren;

        private IList<ActivityDelegate> _delegates;
        private IList<ActivityDelegate> _implementationDelegates;
        private IList<ActivityDelegate> _importedDelegates;

        private IList<Variable> _variables;
        private IList<Variable> _implementationVariables;

        private IList<ValidationError> _tempValidationErrors;
        private IList<RuntimeArgument> _tempAutoGeneratedArguments;

        private Collection<Constraint> _constraints;
        private Activity _runtimeImplementation;

        private Activity _rootActivity;
        private object _thisLock;

        private QualifiedId _qualifiedId;

        // For a given cacheId this tells us whether we've called InternalCacheMetadata yet or not
        private CacheStates _isMetadataCached;
        private int _cacheId;

        private RelationshipType _relationshipToParent;
        private Nullable<bool> _isSubtreeEmpty;

        private int _symbolCount;

        // alternatives are extended through DynamicActivity, CodeActivity, and NativeActivity
        protected Activity()
        {
            _thisLock = new object();
        }

        //[TypeConverter(typeof(ImplementationVersionConverter))]
        [DefaultValue(null)]
        protected virtual internal Version ImplementationVersion
        {
            get;
            set;
        }

        //[XamlDeferLoad(typeof(FuncDeferringLoader), typeof(Activity))]
        [DefaultValue(null)]
        //[Browsable(false)]
        //[Ambient]
        protected virtual Func<Activity> Implementation
        {
            get;
            set;
        }

        protected Collection<Constraint> Constraints
        {
            get
            {
                if (_constraints == null)
                {
                    _constraints = new Collection<Constraint>();
                }
                return _constraints;
            }
        }

        protected internal int CacheId
        {
            get
            {
                return _cacheId;
            }
        }

        internal RelationshipType RelationshipToParent
        {
            get
            {
                return _relationshipToParent;
            }
        }

        internal bool HasNonEmptySubtree
        {
            get
            {
                if (_isSubtreeEmpty.HasValue)
                {
                    return !_isSubtreeEmpty.Value;
                }
                else
                {
                    if (this.Children.Count > 0 || this.ImplementationChildren.Count > 0 || this.ImportedChildren.Count > 0 ||
                        this.Delegates.Count > 0 || this.ImplementationDelegates.Count > 0 || this.ImportedDelegates.Count > 0 ||
                        this.RuntimeVariables.Count > 0 || this.ImplementationVariables.Count > 0 ||
                        this.RuntimeArguments.Count > 0)
                    {
                        _isSubtreeEmpty = false;
                    }
                    else
                    {
                        _isSubtreeEmpty = true;
                    }
                    return !_isSubtreeEmpty.Value;
                }
            }
        }

        internal int SymbolCount
        {
            get
            {
                return _symbolCount;
            }
        }

        internal IdSpace MemberOf
        {
            get;
            set;
        }

        internal IdSpace ParentOf
        {
            get;
            set;
        }

        internal QualifiedId QualifiedId
        {
            get
            {
                if (_qualifiedId == null)
                {
                    _qualifiedId = new QualifiedId(this);
                }

                return _qualifiedId;
            }
        }

        // This flag governs special behavior that we need to keep for back-compat on activities
        // that implemented TryGetValue in 4.0.
        internal bool UseOldFastPath
        {
            get;
            set;
        }

        internal bool SkipArgumentResolution
        {
            get;
            set;
        }

        internal bool IsFastPath
        {
            get
            {
                return this.SkipArgumentResolution && IsActivityWithResult;
            }
        }

        internal virtual bool IsActivityWithResult
        {
            get
            {
                return false;
            }
        }

        internal object Origin
        {
            get;
            set;
        }

        public string DisplayName
        {
            get
            {
                if (!_isDisplayNameSet && string.IsNullOrEmpty(_displayName))
                {
                    _displayName = ActivityUtilities.GetDisplayName(this);
                }

                return _displayName;
            }
            set
            {
                if (value == null)
                {
                    _displayName = string.Empty;
                }
                else
                {
                    _displayName = value;
                }
                _isDisplayNameSet = true;
            }
        }

        public string Id
        {
            get
            {
                if (_id == 0)
                {
                    return null;
                }
                else
                {
                    return this.QualifiedId.ToString();
                }
            }
        }

        internal bool IsExpressionRoot
        {
            get
            {
                return _relationshipToParent == RelationshipType.ArgumentExpression;
            }
        }

        internal bool HasStartedCachingMetadata
        {
            get
            {
                return _isMetadataCached != CacheStates.Uncached;
            }
        }

        internal bool IsMetadataCached
        {
            get
            {
                return _isMetadataCached != CacheStates.Uncached;
            }
        }

        internal bool IsMetadataFullyCached
        {
            get
            {
                return (_isMetadataCached & CacheStates.Full) == CacheStates.Full;
            }
        }

        internal bool IsRuntimeReady
        {
            get
            {
                return (_isMetadataCached & CacheStates.RuntimeReady) == CacheStates.RuntimeReady;
            }
        }

        internal Activity RootActivity
        {
            get
            {
                return _rootActivity;
            }
        }

        internal int InternalId
        {
            get
            {
                return _id;
            }
            set
            {
                Fx.Assert(value != 0, "0 is an invalid ID");
                ClearIdInfo();
                _id = value;
            }
        }

        internal ActivityDelegate HandlerOf
        {
            get;
            private set;
        }

        internal Activity Parent
        {
            get;
            private set;
        }

        internal LocationReferenceEnvironment HostEnvironment
        {
            get
            {
                if (this.RootActivity != null && this.RootActivity._rootProperties != null)
                {
                    return this.RootActivity._rootProperties.HostEnvironment;
                }

                return null;
            }
        }

        internal IList<RuntimeArgument> RuntimeArguments
        {
            get
            {
                return _arguments;
            }
        }

        internal IList<Activity> Children
        {
            get
            {
                return _children;
            }
        }

        internal IList<Activity> ImplementationChildren
        {
            get
            {
                return _implementationChildren;
            }
        }

        internal IList<Activity> ImportedChildren
        {
            get
            {
                return _importedChildren;
            }
        }

        internal IList<ActivityDelegate> Delegates
        {
            get
            {
                return _delegates;
            }
        }

        internal IList<ActivityDelegate> ImplementationDelegates
        {
            get
            {
                return _implementationDelegates;
            }
        }

        internal IList<ActivityDelegate> ImportedDelegates
        {
            get
            {
                return _importedDelegates;
            }
        }

        internal bool HasBeenAssociatedWithAnInstance
        {
            get
            {
                if (_rootProperties != null)
                {
                    return _rootProperties.HasBeenAssociatedWithAnInstance;
                }
                else if (this.IsMetadataCached && this.RootActivity != null && this.RootActivity._rootProperties != null)
                {
                    return this.RootActivity._rootProperties.HasBeenAssociatedWithAnInstance;
                }
                else
                {
                    return false;
                }
            }
            set
            {
                Fx.Assert(_rootProperties != null, "This should only be called on the root and we should already be cached.");
                Fx.Assert(value, "We really only let you set this to true.");

                _rootProperties.HasBeenAssociatedWithAnInstance = value;
            }
        }

        internal Dictionary<string, List<RuntimeArgument>> OverloadGroups
        {
            get
            {
                Fx.Assert(_rootProperties != null || System.Diagnostics.Debugger.IsAttached, "This should only be called on the root.");
                return _rootProperties.OverloadGroups;
            }
            set
            {
                Fx.Assert(_rootProperties != null, "This should only be called on the root.");
                _rootProperties.OverloadGroups = value;
            }
        }

        internal List<RuntimeArgument> RequiredArgumentsNotInOverloadGroups
        {
            get
            {
                Fx.Assert(_rootProperties != null || System.Diagnostics.Debugger.IsAttached, "This should only be called on the root.");
                return _rootProperties.RequiredArgumentsNotInOverloadGroups;
            }
            set
            {
                Fx.Assert(_rootProperties != null, "This should only be called on the root.");
                _rootProperties.RequiredArgumentsNotInOverloadGroups = value;
            }
        }

        internal ValidationHelper.OverloadGroupEquivalenceInfo EquivalenceInfo
        {
            get
            {
                Fx.Assert(_rootProperties != null || System.Diagnostics.Debugger.IsAttached, "This should only be called on the root.");
                return _rootProperties.EquivalenceInfo;
            }
            set
            {
                Fx.Assert(_rootProperties != null, "This should only be called on the root.");
                _rootProperties.EquivalenceInfo = value;
            }
        }

        internal IList<Variable> RuntimeVariables
        {
            get
            {
                return _variables;
            }
        }

        internal IList<Variable> ImplementationVariables
        {
            get
            {
                return _implementationVariables;
            }
        }

        internal IList<Constraint> RuntimeConstraints
        {
            get
            {
                return InternalGetConstraints();
            }
        }

        internal LocationReferenceEnvironment PublicEnvironment
        {
            get;
            set;
        }

        internal LocationReferenceEnvironment ImplementationEnvironment
        {
            get;
            set;
        }

        internal virtual bool InternalCanInduceIdle
        {
            get
            {
                return false;
            }
        }

        internal bool HasTempViolations
        {
            get
            {
                return (_tempValidationErrors != null && _tempValidationErrors.Count > 0);
            }
        }

        internal object ThisLock
        {
            get
            {
                return _thisLock;
            }
        }

        internal int RequiredExtensionTypesCount
        {
            get
            {
                Fx.Assert(_rootProperties != null || System.Diagnostics.Debugger.IsAttached, "only callable on the root");
                return _rootProperties.RequiredExtensionTypesCount;
            }
        }

        internal int DefaultExtensionsCount
        {
            get
            {
                Fx.Assert(_rootProperties != null || System.Diagnostics.Debugger.IsAttached, "only callable on the root");
                return _rootProperties.DefaultExtensionsCount;
            }
        }

        internal bool GetActivityExtensionInformation(out Dictionary<Type, WorkflowInstanceExtensionProvider> activityExtensionProviders, out HashSet<Type> requiredActivityExtensionTypes)
        {
            Fx.Assert(_rootProperties != null, "only callable on the root");
            return _rootProperties.GetActivityExtensionInformation(out activityExtensionProviders, out requiredActivityExtensionTypes);
        }

        internal virtual bool IsResultArgument(RuntimeArgument argument)
        {
            return false;
        }

        internal bool CanBeScheduledBy(Activity parent)
        {
            // fast path if we're the sole (or first) child
            if (object.ReferenceEquals(parent, this.Parent))
            {
                return _relationshipToParent == RelationshipType.ImplementationChild || _relationshipToParent == RelationshipType.Child;
            }
            else
            {
                return parent.Children.Contains(this) || parent.ImplementationChildren.Contains(this);
            }
        }

        internal void ClearIdInfo()
        {
            if (this.ParentOf != null)
            {
                this.ParentOf.Dispose();
                this.ParentOf = null;
            }

            _id = 0;
            _qualifiedId = null;
        }

        // We use these Set methods rather than a setter on the property since
        // we don't want to make it seem like setting these collections is the
        // "normal" thing to do.  Only OnInternalCacheMetadata implementations
        // should call these methods.
        internal void SetChildrenCollection(Collection<Activity> children)
        {
            _children = children;
        }

        internal void AddChild(Activity child)
        {
            if (_children == null)
            {
                _children = new Collection<Activity>();
            }

            _children.Add(child);
        }

        internal void SetImplementationChildrenCollection(Collection<Activity> implementationChildren)
        {
            _implementationChildren = implementationChildren;
        }

        internal void AddImplementationChild(Activity implementationChild)
        {
            if (_implementationChildren == null)
            {
                _implementationChildren = new Collection<Activity>();
            }

            _implementationChildren.Add(implementationChild);
        }

        internal void SetImportedChildrenCollection(Collection<Activity> importedChildren)
        {
           this._importedChildren = importedChildren;
        }

        internal void AddImportedChild(Activity importedChild)
        {
            if (_importedChildren == null)
            {
                _importedChildren = new Collection<Activity>();
            }

            _importedChildren.Add(importedChild);
        }

        internal void SetDelegatesCollection(Collection<ActivityDelegate> delegates)
        {
            _delegates = delegates;
        }

        internal void AddDelegate(ActivityDelegate activityDelegate)
        {
            if (_delegates == null)
            {
                _delegates = new Collection<ActivityDelegate>();
            }

            _delegates.Add(activityDelegate);
        }

        internal void SetImplementationDelegatesCollection(Collection<ActivityDelegate> implementationDelegates)
        {
            _implementationDelegates = implementationDelegates;
        }

        internal void AddImplementationDelegate(ActivityDelegate implementationDelegate)
        {
            if (_implementationDelegates == null)
            {
                _implementationDelegates = new Collection<ActivityDelegate>();
            }

            _implementationDelegates.Add(implementationDelegate);
        }

        internal void SetImportedDelegatesCollection(Collection<ActivityDelegate> importedDelegates)
        {
            _importedDelegates = importedDelegates;
        }

        internal void AddImportedDelegate(ActivityDelegate importedDelegate)
        {
            if (_importedDelegates == null)
            {
                _importedDelegates = new Collection<ActivityDelegate>();
            }

            _importedDelegates.Add(importedDelegate);
        }

        internal void SetVariablesCollection(Collection<Variable> variables)
        {
            _variables = variables;
        }

        internal void AddVariable(Variable variable)
        {
            if (_variables == null)
            {
                _variables = new Collection<Variable>();
            }

            _variables.Add(variable);
        }

        internal void SetImplementationVariablesCollection(Collection<Variable> implementationVariables)
        {
            _implementationVariables = implementationVariables;
        }

        internal void AddImplementationVariable(Variable implementationVariable)
        {
            if (_implementationVariables == null)
            {
                _implementationVariables = new Collection<Variable>();
            }

            _implementationVariables.Add(implementationVariable);
        }

        internal void SetArgumentsCollection(Collection<RuntimeArgument> arguments, bool createEmptyBindings)
        {
            _arguments = arguments;

            // Arguments should always be "as bound as possible"
            if (_arguments != null && _arguments.Count > 0)
            {
                for (int i = 0; i < _arguments.Count; i++)
                {
                    RuntimeArgument argument = _arguments[i];

                    argument.SetupBinding(this, createEmptyBindings);
                }

                _arguments.QuickSort(RuntimeArgument.EvaluationOrderComparer);
            }
        }

        internal void AddArgument(RuntimeArgument argument, bool createEmptyBindings)
        {
            if (_arguments == null)
            {
                _arguments = new Collection<RuntimeArgument>();
            }

            argument.SetupBinding(this, createEmptyBindings);

            int insertionIndex = _arguments.BinarySearch(argument, RuntimeArgument.EvaluationOrderComparer);
            if (insertionIndex < 0)
            {
                _arguments.Insert(~insertionIndex, argument);
            }
            else
            {
                _arguments.Insert(insertionIndex, argument);
            }
        }

        internal void SetTempValidationErrorCollection(IList<ValidationError> validationErrors)
        {
            _tempValidationErrors = validationErrors;
        }

        internal void TransferTempValidationErrors(ref IList<ValidationError> newList)
        {
            if (_tempValidationErrors != null)
            {
                for (int i = 0; i < _tempValidationErrors.Count; i++)
                {
                    ActivityUtilities.Add(ref newList, _tempValidationErrors[i]);
                }
            }
            _tempValidationErrors = null;
        }

        internal void AddTempValidationError(ValidationError validationError)
        {
            if (_tempValidationErrors == null)
            {
                _tempValidationErrors = new Collection<ValidationError>();
            }

            _tempValidationErrors.Add(validationError);
        }

        internal RuntimeArgument AddTempAutoGeneratedArgument(Type argumentType, ArgumentDirection direction)
        {
            if (_tempAutoGeneratedArguments == null)
            {
                _tempAutoGeneratedArguments = new Collection<RuntimeArgument>();
            }

            string name = generatedArgumentPrefix + _tempAutoGeneratedArguments.Count.ToString(CultureInfo.InvariantCulture);
            RuntimeArgument argument = new RuntimeArgument(name, argumentType, direction);
            _tempAutoGeneratedArguments.Add(argument);
            return argument;
        }

        internal void ResetTempAutoGeneratedArguments()
        {
            _tempAutoGeneratedArguments = null;
        }

        internal virtual IList<Constraint> InternalGetConstraints()
        {
            if (_constraints != null && _constraints.Count > 0)
            {
                return _constraints;
            }
            else
            {
                return Activity.EmptyConstraints;
            }
        }

        internal static bool NullCheck<T>(T obj)
        {
            return (obj == null);
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.CurrentCulture, "{0}: {1}", this.Id, this.DisplayName);
        }

        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool ShouldSerializeDisplayName()
        {
            return _isDisplayNameSet;
        }

        // subclasses are responsible for creating/disposing the necessary contexts
        internal virtual void InternalAbort(ActivityInstance instance, ActivityExecutor executor, Exception terminationReason)
        {
        }

        // subclasses are responsible for creating/disposing the necessary contexts
        internal virtual void InternalExecute(ActivityInstance instance, ActivityExecutor executor, BookmarkManager bookmarkManager)
        {
            if (_runtimeImplementation != null)
            {
                executor.ScheduleActivity(_runtimeImplementation, instance, null, null, null);
            }
        }

        // subclasses are responsible for creating/disposing the necessary contexts. This implementation
        // covers Activity, Activity<T>, DynamicActivity, DynamicActivity<T>
        internal virtual void InternalCancel(ActivityInstance instance, ActivityExecutor executor, BookmarkManager bookmarkManager)
        {
            NativeActivityContext context = executor.NativeActivityContextPool.Acquire();
            try
            {
                context.Initialize(instance, executor, bookmarkManager);
                context.Cancel();
            }
            finally
            {
                context.Dispose();
                executor.NativeActivityContextPool.Release(context);
            }
        }

        internal bool IsSingletonActivityDeclared(string name)
        {
            if (_rootActivity == null || _rootActivity._rootProperties == null)
            {
                return false;
            }
            else
            {
                return _rootActivity._rootProperties.IsSingletonActivityDeclared(name);
            }
        }

        internal void DeclareSingletonActivity(string name, Activity activity)
        {
            if (_rootActivity != null && _rootActivity._rootProperties != null)
            {
                _rootActivity._rootProperties.DeclareSingletonActivity(name, activity);
            }
        }

        internal Activity GetSingletonActivity(string name)
        {
            if (_rootActivity != null && _rootActivity._rootProperties != null)
            {
                return _rootActivity._rootProperties.GetSingletonActivity(name);
            }

            return null;
        }

        internal void ClearCachedInformation()
        {
            ClearCachedMetadata();
            _isMetadataCached = CacheStates.Uncached;
        }

        internal void InitializeAsRoot(LocationReferenceEnvironment hostEnvironment)
        {
            // We're being treated as the root of the workflow
            this.Parent = null;
            this.ParentOf = null;

            Interlocked.CompareExchange(ref s_nextCacheId, 1, int.MaxValue);
            _cacheId = Interlocked.Increment(ref s_nextCacheId);

            ClearCachedInformation();

            this.MemberOf = new IdSpace();
            _rootProperties = new RootProperties();
            _rootProperties.HostEnvironment = hostEnvironment;
            _rootActivity = this;
        }

        internal LocationReferenceEnvironment GetParentEnvironment()
        {
            LocationReferenceEnvironment parentEnvironment = null;

            if (this.Parent == null)
            {
                Fx.Assert(_rootProperties != null, "Root properties must be available now.");

                parentEnvironment = new ActivityLocationReferenceEnvironment(_rootProperties.HostEnvironment) { InternalRoot = this };
            }
            else
            {
                switch (_relationshipToParent)
                {
                    case RelationshipType.ArgumentExpression:
                        parentEnvironment = this.Parent.PublicEnvironment.Parent;

                        if (parentEnvironment == null)
                        {
                            parentEnvironment = this.RootActivity._rootProperties.HostEnvironment;
                        }
                        break;
                    case RelationshipType.DelegateHandler:
                        Fx.Assert(this.HandlerOf != null, "Must have the parent delegate set");

                        parentEnvironment = this.HandlerOf.Environment;
                        break;
                    case RelationshipType.Child:
                    case RelationshipType.ImportedChild:
                    case RelationshipType.VariableDefault:
                        parentEnvironment = this.Parent.PublicEnvironment;
                        break;
                    case RelationshipType.ImplementationChild:
                        parentEnvironment = this.Parent.ImplementationEnvironment;
                        break;
                }
            }

            return parentEnvironment;
        }

        internal bool InitializeRelationship(ActivityDelegate activityDelegate, ActivityCollectionType collectionType, ref IList<ValidationError> validationErrors)
        {
            if (_cacheId == activityDelegate.Owner.CacheId)
            {
                // This means that we already have a parent and a delegate is trying to initialize
                // a relationship.  Delegate handlers MUST be declared.
                ActivityUtilities.Add(ref validationErrors, new ValidationError(SR.ActivityDelegateHandlersMustBeDeclarations(this.DisplayName, activityDelegate.Owner.DisplayName, this.Parent.DisplayName), false, activityDelegate.Owner));

                return false;
            }

            if (InitializeRelationship(activityDelegate.Owner, collectionType != ActivityCollectionType.Implementation, RelationshipType.DelegateHandler, ref validationErrors))
            {
                this.HandlerOf = activityDelegate;

                return true;
            }

            return false;
        }

        internal bool InitializeRelationship(RuntimeArgument argument, ref IList<ValidationError> validationErrors)
        {
            return InitializeRelationship(argument.Owner, true, RelationshipType.ArgumentExpression, ref validationErrors);
        }

        internal bool InitializeRelationship(Variable variable, bool isPublic, ref IList<ValidationError> validationErrors)
        {
            return InitializeRelationship(variable.Owner, isPublic, RelationshipType.VariableDefault, ref validationErrors);
        }

        internal bool InitializeRelationship(Activity parent, ActivityCollectionType collectionType, ref IList<ValidationError> validationErrors)
        {
            RelationshipType relationshipType = RelationshipType.Child;
            if (collectionType == ActivityCollectionType.Imports)
            {
                relationshipType = RelationshipType.ImportedChild;
            }
            else if (collectionType == ActivityCollectionType.Implementation)
            {
                relationshipType = RelationshipType.ImplementationChild;
            }

            return InitializeRelationship(parent, collectionType != ActivityCollectionType.Implementation, relationshipType, ref validationErrors);
        }

        private bool InitializeRelationship(Activity parent, bool isPublic, RelationshipType relationship, ref IList<ValidationError> validationErrors)
        {
            if (_cacheId == parent._cacheId)
            {
                // This means that we've already encountered a parent in the tree

                // Validate that it is visible.

                // In order to see the activity the new parent must be
                // in the implementation IdSpace of an activity which has
                // a public reference to it.
                Activity referenceTarget = parent.MemberOf.Owner;

                if (object.ReferenceEquals(this, parent))
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(SR.ActivityCannotReferenceItself(this.DisplayName), parent));

                    return false;
                }
                else if (this.Parent == null)
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(SR.RootActivityCannotBeReferenced(this.DisplayName, parent.DisplayName), parent));

                    return false;
                }
                else if (referenceTarget == null)
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(SR.ActivityCannotBeReferencedWithoutTarget(this.DisplayName, parent.DisplayName, this.Parent.DisplayName), parent));

                    return false;
                }
                else if (!referenceTarget.Children.Contains(this) && !referenceTarget.ImportedChildren.Contains(this))
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(SR.ActivityCannotBeReferenced(this.DisplayName, parent.DisplayName, referenceTarget.DisplayName, this.Parent.DisplayName), false, parent));

                    return false;
                }

                // This is a valid reference so we want to allow
                // normal processing to proceed.
                return true;
            }

            this.Parent = parent;
            this.HandlerOf = null;
            _rootActivity = parent.RootActivity;
            _cacheId = parent._cacheId;
            _isMetadataCached = CacheStates.Uncached;
            ClearCachedMetadata();
            _relationshipToParent = relationship;

            if (isPublic)
            {
                this.MemberOf = parent.MemberOf;
            }
            else
            {
                if (parent.ParentOf == null)
                {
                    parent.ParentOf = new IdSpace(parent.MemberOf, parent.InternalId);
                }

                this.MemberOf = parent.ParentOf;
            }

            return true;
        }

        private void ClearCachedMetadata()
        {
            _symbolCount = 0;

            _arguments = null;

            _children = null;
            _implementationChildren = null;
            _importedChildren = null;

            _delegates = null;
            _implementationDelegates = null;
            _importedDelegates = null;

            _variables = null;
            _implementationVariables = null;
        }

        internal void InternalCacheMetadata(bool createEmptyBindings, ref IList<ValidationError> validationErrors)
        {
            OnInternalCacheMetadata(createEmptyBindings);

            if (_tempAutoGeneratedArguments != null)
            {
                Fx.Assert(_tempAutoGeneratedArguments.Count > 0, "We should only have a non-null value here if we generated an argument");
                if (!this.SkipArgumentResolution)
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(
                        SR.PublicReferencesOnActivityRequiringArgumentResolution(this.DisplayName), false, this));
                }

                if (_arguments == null)
                {
                    _arguments = _tempAutoGeneratedArguments;
                }
                else
                {
                    for (int i = 0; i < _tempAutoGeneratedArguments.Count; i++)
                    {
                        _arguments.Add(_tempAutoGeneratedArguments[i]);
                    }
                }

                _tempAutoGeneratedArguments = null;
            }

            if (_arguments != null && _arguments.Count > 1)
            {
                ActivityValidationServices.ValidateEvaluationOrder(_arguments, this, ref _tempValidationErrors);
            }

            if (_tempValidationErrors != null)
            {
                if (validationErrors == null)
                {
                    validationErrors = new List<ValidationError>();
                }

                for (int i = 0; i < _tempValidationErrors.Count; i++)
                {
                    ValidationError validationError = _tempValidationErrors[i];

                    validationError.Source = this;
                    validationError.Id = this.Id;

                    validationErrors.Add(validationError);
                }

                _tempValidationErrors = null;
            }

            if (_arguments == null)
            {
                _arguments = s_emptyArguments;
            }
            else
            {
                _symbolCount += _arguments.Count;
            }

            if (_variables == null)
            {
                _variables = s_emptyVariables;
            }
            else
            {
                _symbolCount += _variables.Count;
            }

            if (_implementationVariables == null)
            {
                _implementationVariables = s_emptyVariables;
            }
            else
            {
                _symbolCount += _implementationVariables.Count;
            }

            if (_children == null)
            {
                _children = s_emptyChildren;
            }

            if (_importedChildren == null)
            {
                _importedChildren = s_emptyChildren;
            }

            if (_implementationChildren == null)
            {
                _implementationChildren = s_emptyChildren;
            }

            if (_delegates == null)
            {
                _delegates = s_emptyDelegates;
            }

            if (_importedDelegates == null)
            {
                _importedDelegates = s_emptyDelegates;
            }

            if (_implementationDelegates == null)
            {
                _implementationDelegates = s_emptyDelegates;
            }

            _isMetadataCached = CacheStates.Partial;
        }

        // Note that this is relative to the type of walk we've done.  If we
        // skipped implementation then we can still be "Cached" even though
        // we never ignored the implementation.
        internal void SetCached(bool isSkippingPrivateChildren)
        {
            if (isSkippingPrivateChildren)
            {
                _isMetadataCached = CacheStates.Partial;
            }
            else
            {
                _isMetadataCached = CacheStates.Full;
            }
        }

        internal void SetRuntimeReady()
        {
            _isMetadataCached |= CacheStates.RuntimeReady;
        }

        internal virtual void OnInternalCacheMetadata(bool createEmptyBindings)
        {
            // By running CacheMetadata first we allow the user
            // to set their Implementation during CacheMetadata.
            ActivityMetadata metadata = new ActivityMetadata(this, GetParentEnvironment(), createEmptyBindings);
            CacheMetadata(metadata);
            metadata.Dispose();

            if (this.Implementation != null)
            {
                _runtimeImplementation = this.Implementation();
            }
            else
            {
                _runtimeImplementation = null;
            }

            if (_runtimeImplementation != null)
            {
                SetImplementationChildrenCollection(new Collection<Activity>
                {
                    _runtimeImplementation
                });
            }
        }

#if NETSTANDARD1_5

        protected virtual void CacheMetadata(ActivityMetadata metadata)
        {
           ReflectedInformation information = new ReflectedInformation(this);

           SetImportedChildrenCollection(information.GetChildren());
           SetVariablesCollection(information.GetVariables());
           SetImportedDelegatesCollection(information.GetDelegates());
           SetArgumentsCollection(information.GetArguments(), metadata.CreateEmptyBindings);
        }

#else

        protected abstract void CacheMetadata(ActivityMetadata metadata);

#endif

        //internal virtual void OnInternalCreateDynamicUpdateMap(DynamicUpdateMapBuilder.Finalizer finalizer,
        //    DynamicUpdateMapBuilder.IDefinitionMatcher matcher, Activity originalActivity)
        //{
        //    UpdateMapMetadata metadata = new UpdateMapMetadata(finalizer, matcher, this);
        //    try
        //    {
        //        OnCreateDynamicUpdateMap(metadata, originalActivity);
        //    }
        //    finally
        //    {
        //        metadata.Dispose();
        //    }
        //}

        //protected virtual void OnCreateDynamicUpdateMap(UpdateMapMetadata metadata, Activity originalActivity)
        //{
        //}

        internal void AddDefaultExtensionProvider<T>(Func<T> extensionProvider)
            where T : class
        {
            Fx.Assert(extensionProvider != null, "caller must verify");
            Fx.Assert(_rootActivity != null && _rootActivity._rootProperties != null, "need a valid root");
            _rootActivity._rootProperties.AddDefaultExtensionProvider(extensionProvider);
        }

        internal void RequireExtension(Type extensionType)
        {
            Fx.Assert(extensionType != null && !extensionType.GetTypeInfo().IsValueType, "caller should verify we have a valid reference type");
            Fx.Assert(_rootActivity != null && _rootActivity._rootProperties != null, "need a valid root");
            _rootActivity._rootProperties.RequireExtension(extensionType);
        }

        // information used by root activities
        private class RootProperties
        {
            private Dictionary<string, Activity> _singletonActivityNames;
            private Dictionary<Type, WorkflowInstanceExtensionProvider> _activityExtensionProviders;
            private HashSet<Type> _requiredExtensionTypes;

            public RootProperties()
            {
            }

            public bool HasBeenAssociatedWithAnInstance
            {
                get;
                set;
            }

            public LocationReferenceEnvironment HostEnvironment
            {
                get;
                set;
            }

            public Dictionary<string, List<RuntimeArgument>> OverloadGroups
            {
                get;
                set;
            }

            public List<RuntimeArgument> RequiredArgumentsNotInOverloadGroups
            {
                get;
                set;
            }

            public ValidationHelper.OverloadGroupEquivalenceInfo EquivalenceInfo
            {
                get;
                set;
            }

            public int DefaultExtensionsCount
            {
                get
                {
                    if (_activityExtensionProviders != null)
                    {
                        return _activityExtensionProviders.Count;
                    }
                    else
                    {
                        return 0;
                    }
                }
            }

            public int RequiredExtensionTypesCount
            {
                get
                {
                    if (_requiredExtensionTypes != null)
                    {
                        return _requiredExtensionTypes.Count;
                    }
                    else
                    {
                        return 0;
                    }
                }
            }

            public bool GetActivityExtensionInformation(out Dictionary<Type, WorkflowInstanceExtensionProvider> activityExtensionProviders, out HashSet<Type> requiredActivityExtensionTypes)
            {
                activityExtensionProviders = _activityExtensionProviders;
                requiredActivityExtensionTypes = _requiredExtensionTypes;
                return activityExtensionProviders != null || (_requiredExtensionTypes != null && _requiredExtensionTypes.Count > 0);
            }

            public void AddDefaultExtensionProvider<T>(Func<T> extensionProvider)
                where T : class
            {
                Type key = typeof(T);
                if (_activityExtensionProviders == null)
                {
                    _activityExtensionProviders = new Dictionary<Type, WorkflowInstanceExtensionProvider>();
                }
                else
                {
                    if (_activityExtensionProviders.ContainsKey(key))
                    {
                        return; // already have a provider of this type
                    }
                }

                _activityExtensionProviders.Add(key, new WorkflowInstanceExtensionProvider<T>(extensionProvider));

                // if we're providing an extension that exactly matches a required type, simplify further bookkeeping
                if (_requiredExtensionTypes != null)
                {
                    _requiredExtensionTypes.Remove(key);
                }
            }

            public void RequireExtension(Type extensionType)
            {
                // if we're providing an extension that exactly matches a required type, don't bother with further bookkeeping
                if (_activityExtensionProviders != null && _activityExtensionProviders.ContainsKey(extensionType))
                {
                    return;
                }

                if (_requiredExtensionTypes == null)
                {
                    _requiredExtensionTypes = new HashSet<Type>();
                }
                _requiredExtensionTypes.Add(extensionType);
            }

            public bool IsSingletonActivityDeclared(string name)
            {
                if (_singletonActivityNames == null)
                {
                    return false;
                }
                else
                {
                    return _singletonActivityNames.ContainsKey(name);
                }
            }

            public void DeclareSingletonActivity(string name, Activity activity)
            {
                if (_singletonActivityNames == null)
                {
                    _singletonActivityNames = new Dictionary<string, Activity>(1);
                }

                _singletonActivityNames.Add(name, activity);
            }

            public Activity GetSingletonActivity(string name)
            {
                Activity result = null;
                if (_singletonActivityNames != null)
                {
                    _singletonActivityNames.TryGetValue(name, out result);
                }

                return result;
            }
        }

        internal enum RelationshipType : byte
        {
            Child = 0x00,
            ImportedChild = 0x01,
            ImplementationChild = 0x02,
            DelegateHandler = 0x03,
            ArgumentExpression = 0x04,
            VariableDefault = 0x05
        }

        private enum CacheStates : byte
        {
            // We don't have valid cached data
            Uncached = 0x00,

            // The next two states are mutually exclusive:

            // The activity has its own metadata cached, or private implementation are skipped
            Partial = 0x01,

            // The activity has its own metadata and its private implementation cached
            // We can make use of the roll-up metadata (like
            // SubtreeHasConstraints).
            Full = 0x02,

            // The next state can be ORed with the last two:

            // The cached data is ready for runtime use
            RuntimeReady = 0x04
        }
    }

    //[TypeConverter(typeof(ActivityWithResultConverter))]
    //[ValueSerializer(typeof(ActivityWithResultValueSerializer))]
    public abstract class Activity<TResult> : ActivityWithResult
    {
        // alternatives are extended through DynamicActivity<TResult>, CodeActivity<TResult>, and NativeActivity<TResult>
        protected Activity()
            : base()
        {
        }

        [DefaultValue(null)]
        public new OutArgument<TResult> Result
        {
            get;
            set;
        }

        internal override Type InternalResultType
        {
            get
            {
                return typeof(TResult);
            }
        }

        internal override OutArgument ResultCore
        {
            get
            {
                return this.Result;
            }
            set
            {
                this.Result = value as OutArgument<TResult>;

                if (this.Result == null && value != null)
                {
                    throw CoreWf.Internals.FxTrace.Exception.Argument("value", SR.ResultArgumentMustBeSpecificType(typeof(TResult)));
                }
            }
        }

        public static implicit operator Activity<TResult>(TResult constValue)
        {
            return FromValue(constValue);
        }

        public static implicit operator Activity<TResult>(Variable variable)
        {
            return FromVariable(variable);
        }

        public static implicit operator Activity<TResult>(Variable<TResult> variable)
        {
            return FromVariable(variable);
        }

        public static Activity<TResult> FromValue(TResult constValue)
        {
            return new Literal<TResult> { Value = constValue };
        }

        public static Activity<TResult> FromVariable(Variable variable)
        {
            if (variable == null)
            {
                throw CoreWf.Internals.FxTrace.Exception.ArgumentNull("variable");
            }

            if (TypeHelper.AreTypesCompatible(variable.Type, typeof(TResult)))
            {
                return new VariableValue<TResult> { Variable = variable };
            }
            else
            {
                Type locationGenericType;
                if (ActivityUtilities.IsLocationGenericType(typeof(TResult), out locationGenericType))
                {
                    if (locationGenericType == variable.Type)
                    {
                        return (Activity<TResult>)ActivityUtilities.CreateVariableReference(variable);
                    }
                }
            }

            throw CoreWf.Internals.FxTrace.Exception.Argument("variable", SR.ConvertVariableToValueExpressionFailed(variable.GetType().FullName, typeof(Activity<TResult>).FullName));
        }

        //[SuppressMessage(FxCop.Category.Design, FxCop.Rule.ConsiderPassingBaseTypesAsParameters,
        //Justification = "Generic needed for type inference")]
        public static Activity<TResult> FromVariable(Variable<TResult> variable)
        {
            if (variable == null)
            {
                throw CoreWf.Internals.FxTrace.Exception.ArgumentNull("variable");
            }

            return new VariableValue<TResult>(variable);
        }

        internal override bool IsResultArgument(RuntimeArgument argument)
        {
            return object.ReferenceEquals(argument, this.ResultRuntimeArgument);
        }

        internal sealed override void OnInternalCacheMetadata(bool createEmptyBindings)
        {
            OnInternalCacheMetadataExceptResult(createEmptyBindings);

            bool foundResult = false;

            // This could be null at this point
            IList<RuntimeArgument> runtimeArguments = this.RuntimeArguments;

            int runtimeArgumentCount = 0;

            if (runtimeArguments != null)
            {
                runtimeArgumentCount = runtimeArguments.Count;

                for (int i = 0; i < runtimeArgumentCount; i++)
                {
                    RuntimeArgument argument = runtimeArguments[i];

                    if (argument.Name == "Result")
                    {
                        foundResult = true;

                        if (argument.Type != typeof(TResult) || argument.Direction != ArgumentDirection.Out)
                        {
                            // The user supplied "Result" is incorrect so we
                            // log a violation.
                            AddTempValidationError(new ValidationError(SR.ResultArgumentHasRequiredTypeAndDirection(typeof(TResult), argument.Direction, argument.Type)));
                        }
                        else if (!IsBoundArgumentCorrect(argument, createEmptyBindings))
                        {
                            // The user supplied "Result" is not bound to the correct
                            // argument object.
                            AddTempValidationError(new ValidationError(SR.ResultArgumentMustBeBoundToResultProperty));
                        }
                        else
                        {
                            // The user supplied "Result" is correct so we
                            // cache it.
                            this.ResultRuntimeArgument = argument;
                        }

                        break;
                    }
                }
            }

            if (!foundResult)
            {
                this.ResultRuntimeArgument = new RuntimeArgument("Result", typeof(TResult), ArgumentDirection.Out);

                if (this.Result == null)
                {
                    if (createEmptyBindings)
                    {
                        this.Result = new OutArgument<TResult>();
                        Argument.Bind(this.Result, this.ResultRuntimeArgument);
                    }
                    else
                    {
                        OutArgument<TResult> tempArgument = new OutArgument<TResult>();
                        Argument.Bind(tempArgument, this.ResultRuntimeArgument);
                    }
                }
                else
                {
                    Argument.Bind(this.Result, this.ResultRuntimeArgument);
                }


                AddArgument(this.ResultRuntimeArgument, createEmptyBindings);
            }
        }

        private bool IsBoundArgumentCorrect(RuntimeArgument argument, bool createEmptyBindings)
        {
            if (createEmptyBindings)
            {
                // We must match if we've gone through
                // RuntimeArgument.SetupBinding with
                // createEmptyBindings == true.
                return object.ReferenceEquals(argument.BoundArgument, this.Result);
            }
            else
            {
                // Otherwise, if the Result is null then
                // SetupBinding has created a default
                // BoundArgument which is fine.  If it
                // is non-null then it had better match.
                return this.Result == null || object.ReferenceEquals(argument.BoundArgument, this.Result);
            }
        }

        internal virtual void OnInternalCacheMetadataExceptResult(bool createEmptyBindings)
        {
            // default to Activity's behavior
            base.OnInternalCacheMetadata(createEmptyBindings);
        }

        internal override object InternalExecuteInResolutionContextUntyped(CodeActivityContext resolutionContext)
        {
            return InternalExecuteInResolutionContext(resolutionContext);
        }

        internal virtual TResult InternalExecuteInResolutionContext(CodeActivityContext resolutionContext)
        {
            throw Fx.AssertAndThrow("This should only be called on CodeActivity<T>");
        }
    }
}


